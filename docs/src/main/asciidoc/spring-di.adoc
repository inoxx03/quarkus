//TODO: What should we do with this?
////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
////
//TODO: need to use product attributes, but also keep compatibility with community ones

// comment out to show community version
:product-docs:
:doctype: book

ifdef::product-docs[]
//TODO: copy product attribute files over to community repo
//include::common/attributes.adoc[]
//temporary attributes
:ProductName: Quarkus
:ProductLongName: Red Hat build of Quarkus
:maven-version: 3.6.3
endif::[]



//Top-Level Assembly
[id="using-the-quarkus-extension-for-spring-di-api_{context}"]
= Using the Quarkus Extension for Spring DI API

ifdef::context[:parent-context: {context}]
//temporary context value, will be changed before going into production
:context: guide-quarkus-spring-di


[role="_abstract"]
The `quarkus-spring-di` extension provides a compatibility layer for Spring Dependency Injection, that you can use as an alternative to MicroProfile CDI annotations in your Quarkus application.
This guide explains how your {ProductName} application can leverage Dependency Injection annotations provided by the Spring Framework.

ifndef::product-docs[]
//TODO: What should we do with this? Leave it as community-only?

This guide is maintained in the main Quarkus repository and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc

== Solution

We recommend that you follow the instructions in the next sections and create the application step by step.
However, you can go right to the completed example.

Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].

The solution is located in the `spring-di-quickstart` {quickstarts-tree-url}/spring-di-quickstart[directory].
endif::[]

// Tech preview info for community purposes, different from product
ifndef::product-docs[]
include::./attributes.adoc[]
:extension-status: preview
endif::[]

ifdef::product-docs[]
NOTE: The `quarkus-spring-di` extension is available as link:https://access.redhat.com/support/offerings/techpreview[Technology Preview] with {ProductLongName}.
endif::[]

ifndef::product-docs[]
include::./status-include.adoc[]
endif::[]

ifndef::product-docs[]
[IMPORTANT]
====
Note that the Spring support in Quarkus does not start a Spring Application Context nor are any Spring infrastructure classes run.
Spring classes and annotations are only used for reading metadata and / or are used as user code method return types or parameter types.
What that means for end users, is that adding arbitrary Spring libraries will not have any effect. Moreover Spring infrastructure
classes (like `org.springframework.beans.factory.config.BeanPostProcessor` for example) will not be executed.
====
endif::[]

.Prerequisites

// comment out the following prerequisite in the alternative 1 layout of the document.
* You have a {ProductName} Maven project.
* You have OpenJDK 8 installed.
* You have Maven {maven-version} installed.

// Alternative 1: generate project form scratch
[id="creating-the-spring-di-example-maven-project_{context}"]
== Creating the Spring DI Example Maven project

[role="_abstract"]
You can create new a new Maven project for the Spring DI example application on the command line.

.Procedure

. Execute the following commands to:

* generate the directory structure of the project
* create the main class file of the example application
* create the endpoint that exposes the service that your application provides
* add the `quarkus-spring-di` extension to the `pom.xml` file of your project
* navigate to the top-level directory of your project
+
[source,bash,subs=attributes+]
----
mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=spring-di-quickstart \
    -DclassName="org.acme.spring.di.GreeterResource" \
    -Dpath="/greeting" \
    -Dextensions="resteasy,spring-di"
cd spring-di-quickstart
----


//Alternative 2: you have a project and need to add the required extension.
[id="setting-up-your-spring-di-maven-project_{context}"]
== Setting up your Spring DI example Maven project

[role="_abstract"]
Add the required {ProductName} extension as a dependency of your Maven project.

.Procedure

. Navigate to the the top-level directory of your {ProductName} Maven project:
+
[source,bash,options="nowrap",subs="+quotes,attributes+"]
----
cd <name-of-your-project-directory>
----

. Execute the following command to add the `quarkus-spring-di` extension to the `pom.xml` file of your project:
+
[source,bash]
----
./mvnw quarkus:add-extension -Dextensions="spring-di"
----
ifndef::product-docs[]
+
This will add the following to your `pom.xml`:

[source,xml]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-spring-di</artifactId>
</dependency>
----
endif::[]


[id="additng-beans-to-your-applications-using-spring-annotations"]
== Adding beans to your application using Spring annotations

[role="_abstract"]
You can add the required beans to your {ProductName} application using annotations provided by Spring.

.Procedure
//. Navigate to the directory that contains your {ProductName} project.
. Navigate to the the top-level directory of your {ProductName} Maven project:
+
[source,bash,options="nowrap",subs="+quotes,attributes+"]
----
cd <name-of-your-project-directory>
----

. Create the `src/main/java/org/acme/spring/di/StringFunction.java` file that contains a `StringFunction` interface:
+
[source,java]
----
package org.acme.spring.di;

import java.util.function.Function;

public interface StringFunction extends Function<String, String> {

}
----
ifndef::product-docs[]
+
//TODO: Not sure where to place this
Other beans in this example implement this interface, and the interface is injected into another bean later on.
endif::[]


. Create the `src/main/java/org/acme/spring/di/AppConfiguration.java` file.
Inside the file that you created, create an `AppConfiguration` class and annotate it with the `@Configuration` annotation provided by Spring Java Config.
Inside the `AppConfiguration` class, create a `StringFunction` bean that changes a string that you pass to it to uppercase:
+
[source,java]
----
package org.acme.spring.di;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfiguration {

    @Bean(name = "capitalizeFunction")
    public StringFunction capitalizer() {
        return String::toUpperCase;
    }
}
----
As a Spring developer, you might be tempted to add the `@ComponentScan` annotation in order to define specific packages to scan for additional beans. Do note that `@ComponentScan` is entirely unnecessary since Quarkus performs link:cdi-reference#bean_discovery[bean discovery] only in `annotated` mode with no visibility boundaries. Moreover, note that the bean discovery in Quarkus happens at build time.
In the same vein, Quarkus does not support the Spring `@Import` annotation.

. Create the `src/main/java/org/acme/spring/di/NoOpSingleStringFunction.java` file,
Inside the file that you created, crate a `NoOpSingleStringFunction` bean.
The `NoOpSingleStringFunction` implements the `StringFunction` bean using the `@Component` stereotype annotation provided by Spring.
Note, that this bean does not process the string, but returns the string as is:
+
[source,java]
----
package org.acme.spring.di;

import org.springframework.stereotype.Component;

@Component("noopFunction")
public class NoOpSingleStringFunction implements StringFunction {

    @Override
    public String apply(String s) {
        return s;
    }
}
----
+
//. Quarkus also provides support for injecting configuration values using Spring's `@Value` annotation.
. With Quarkus, you can also use the `@Value` annotations to inject values of configuration properties into beans:
.. Set the value of the `greeting.message` property to `hello` in the `src/main/resources/application.properties` file:
+
[source,properties]
----
# Your configuration properties
greeting.message = hello
----
+
.. Create the `src/main/java/org/acme/spring/di/MessageProducer.java` file.
Inside the file that you created, crate a `MessageProducer` bean.
Use the `@Value` annotation to set the value of the `greeting.message` property as the message String inside the `MessageProducer` bean:
+
[source,java]
----
package org.acme.spring.di;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class MessageProducer {

    @Value("${greeting.message}")
    String message;

    public String getPrefix() {
        return message;
    }
}
----
+
//The final bean we will create ties together all the previous beans.
. Create the `src/main/java/org/acme/spring/di/GreeterBean.java` file that contains the code shown in the example below.
Note, that the `GreeterBean` bean relies on both constructor-based and field-based injection.
Note, that you do not need to use the `@Autowired` annotation on the field-based constructor, because the bean only contains a single field-based constructor.
Also note, that the `@Value` annotation on the `suffix` String contains a default value.
The default value is used when you do not set a value for the `greeting.suffix` property in the `application.properties` file.
+
[source,java]
----
package org.acme.spring.di;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class GreeterBean {

    private final MessageProducer messageProducer;

    @Autowired
    @Qualifier("noopFunction")
    StringFunction noopStringFunction;

    @Autowired
    @Qualifier("capitalizeFunction")
    StringFunction capitalizerStringFunction;

    @Value("${greeting.suffix:!}")
    String suffix;

    public GreeterBean(MessageProducer messageProducer) {
        this.messageProducer = messageProducer;
    }

    public String greet(String name) {
        final String initialValue = messageProducer.getPrefix() + " " + name + suffix;
        return noopStringFunction.andThen(capitalizerStringFunction).apply(initialValue);
    }
}
----

[id="updating-the-jax-rs-resource_{context}"]
== Updating the JAX-RS resource

[role="_abstract"]
When you create the class files of you example applications, you must also update the `GreeterResource.java` class file.
// TODO: explain why this needs to be done.

.Procedure

. Add the following content to the `src/main/java/org/acme/spring/di/GreeterResource.java` file:

[source,java]
----
package org.acme.spring.di;

import org.springframework.beans.factory.annotation.Autowired;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/greeting")
public class GreeterResource {

    @Autowired
    GreeterBean greeterBean;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return greeterBean.greet("world");
    }
}
----

[id='updating-the-application-test-class_{context}']
== Updating the application test

[role="_abstract"]
You must update the class file that contains the functional test for your application to reflect the changes that you made to the `/greeting` endpoint.

.Procedure

. Edit the `src/test/java/org/acme/spring/di/GreetingResourceTest.java` file and change the content of the `testHelloEndpoint` method as shown in the example below:
+
[source, java]
----
import io.quarkus.test.junit.QuarkusTest;
import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured.given;
import static org.hamcrest.CoreMatchers.is;

@QuarkusTest
public class GreetingResourceTest {

    @Test
    public void testHelloEndpoint() {
        given()
            .when().get("/greeting")
            .then()
                .statusCode(200)
                .body(is("HELLO WORLD!"));
    }

}
----

[id="packaging-and-running-your-spring-di-example-application_{context}"]
== Packaging and running your Spring DI example application

[role="_abstract"]
Package and run your Spring DI example application using Maven.

.Procedure

. Navigate to the the top-level directory of your {ProductName} Maven project:
+
[source,bash,options="nowrap",subs="+quotes,attributes+"]
----
cd <name-of-your-project-directory>
----

. Execute the following command to compile and run your application in development mode:
+
[source,bash]
----
./mvnw compile quarkus:dev
----

. Navigate to `http://localhost:8080/greeting` using a web browser.
You receive `HELLO WORLD!` as the response.

. Press _CTRL + C_ to stop the application.


ifndef::product-docs[]
== Run the application as a native

You can create a native image by following the guide about link:building-native-image[Building a Native Executable].
endif::[]

ifndef::product-docs[]
== Important Technical Note

Note that the Spring support in Quarkus does not start a Spring Application Context nor are any Spring infrastructure classes run.
Spring classes and annotations are only used for reading metadata and / or are used as user code method return types or parameter types.
What that means for end users, is that adding arbitrary Spring libraries will not have any effect. Moreover Spring infrastructure
classes (like `org.springframework.beans.factory.config.BeanPostProcessor` , `org.springframework.context.ApplicationContext` for example) will not be executed.
Regarding the dependency injection in particular, Quarkus uses a Dependency Injection mechanism (called ArC) based on the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0] specification. If you want to learn more about it we recommend you to read the link:cdi[Quarkus introduction to CDI] and the link:cdi-reference#arc-configuration-reference[CDI reference guide]
The various Spring Boot test features are not supported by Quarkus. For testing purposes, please, check the link:getting-started-testing[Quarkus testing guide].

[id="overview-of-annotation-equivalents-in-spring-di-and-cdi"]
== Overview of annotation equivalents in Spring DI and CDI

[role="_abstract"]
The following table shows how Spring DI annotations can be converted to CDI annotations or MicroProfile annotations, respectively.

[options="header"]
|===
|Spring Annotation |CDI / MicroProfile Annotation |Note

|`@Autowired`
|`@Inject`
|

|`@Qualifier`
|`@Named`
|

|`@Value`
|`@ConfigProperty`
|`@ConfigProperty` does not support an expression language the way `@Value` does, but makes the typical use cases much easier to handle

|`@Component`
|`@Singleton`
|By default Spring stereotype annotations are singleton beans

|`@Service`
|`@Singleton`
|By default Spring stereotype annotations are singleton beans

|`@Repository`
|`@Singleton`
|By default Spring stereotype annotations are singleton beans

|`@Configuration`
|`@ApplicationScoped`
|In CDI a producer bean is not limited to the application scope, it could just as well be `@Singleton` or `@Dependent`

|`@Bean`
|`@Produces`
|

|`@Scope`
|
|Does not have a one-to-one mapping to a CDI annotation. Depending on the value of `@Scope`, you can use `@Singleton`, `@ApplicationScoped`, `@SessionScoped`, `@RequestScoped`, or `@Dependent`
|===


ifdef::product-docs[]
[role="_additional-resources"]
.Additional resources
* link:building-native-image[Compiling and running your {ProductName} application as a native executable.]
endif::[]

ifndef::product-docs[]
== More Spring guides

Quarkus has more Spring compatibility features. See the following guides for more details:

* link:spring-web[Quarkus - Extension for Spring Web]
* link:spring-data-jpa[Quarkus - Extension for Spring Data JPA]
* link:spring-data-rest[Quarkus - Extension for Spring Data REST]
* link:spring-security[Quarkus - Extension for Spring Security]
* link:spring-cloud-config-client[Quarkus - Reading properties from Spring Cloud Config Server]
* link:spring-boot-properties[Quarkus - Extension for Spring Boot properties]
* link:spring-cache[Quarkus - Extension for Spring Cache]
* link:spring-scheduled[Quarkus - Extension for Spring Scheduled]
endif::[]

ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]
