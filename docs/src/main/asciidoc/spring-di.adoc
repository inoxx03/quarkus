////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
////
[id="using-the-quarkus-extension-for-spring-di-api_{context}"]
= Using the Quarkus Extension for Spring DI API

//TODO: need to use product attributes, but also keep compatibility with community ones
//include::./attributes.adoc[]
// Tech preview info for community purposes, different form product
//:extension-status: preview

[role="_abstract"]
The Quarkus `spring-di` extension provides a compatibility layer for Spring Dependency Injection, that you can use as an alternative to MicroProfile CDI annotations in your Quarkus application.
This guide explains how your Quarkus application can leverage Dependency Injection annotations provided by the Spring Framework.

// conditionalized the inclusion of community-only status info section
ifdef::product-docs[]
include::./status-include.adoc[]
endif::[]

.Prerequisites

* You have a {ProductName} Maven project.
* You have OpenJDK 8 installed.
* You have Maven {maven-version} installed.


////
== Solution

We recommend that you follow the instructions in the next sections and create the application step by step.
However, you can go right to the completed example.

Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].

The solution is located in the `spring-di-quickstart` {quickstarts-tree-url}/spring-di-quickstart[directory].
////

////
== Creating the Maven project

First, we need a new project. Create a new project with the following command:

[source,bash,subs=attributes+]
----
mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=spring-di-quickstart \
    -DclassName="org.acme.spring.di.GreeterResource" \
    -Dpath="/greeting" \
    -Dextensions="resteasy,spring-di"
cd spring-di-quickstart
----

This command generates a Maven project with a REST endpoint and imports the `spring-di` extension.

If you already have your Quarkus project configured, you can add the `spring-di` extension
to your project by running the following command in your project base directory:

[source,bash]
----
./mvnw quarkus:add-extension -Dextensions="spring-di"
----

This will add the following to your `pom.xml`:

[source,xml]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-spring-di</artifactId>
</dependency>
----
////


//== Add beans using Spring annotations
//PROC
[id="additng-beans-to-your-applications-using-spring-annotations"]
= Adding beans to your application using Spring annotations

. Navigate to the directory that contains your {ProductName} project.

. Add the `quarkus-spring-di` extension as a dependency of your application:
+
[source,bash]
----
./mvnw quarkus:add-extension -Dextensions="spring-di"
----
+
This command adds the following dependency to your `pom.xml` file:
+
[source,xml]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-spring-di</artifactId>
</dependency>
----

//. Create some beans for your application using Spring annotations.

. Create a `src/main/java/org/acme/spring/di/StringFunction.java` file that contains a `StringFunction` interface:
+
[source,java]
----
package org.acme.spring.di;

import java.util.function.Function;

public interface StringFunction extends Function<String, String> {

}
----
+
Other beans in this example implement this interface, and the interface is injected into another bean later on.
//WHEN? Move this information to the relevant place

. Create a `src/main/java/org/acme/spring/di/AppConfiguration.java` file that contains an `AppConfiguration` class and annotate it with the `@Configuration` annotation from Spring Java Config.
Inside the `AppConfiguration` class, create a `StringFunction` bean that changes a string that you pass to it to uppercase:

[source,java]
----
package org.acme.spring.di;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfiguration {

    @Bean(name = "capitalizeFunction")
    public StringFunction capitalizer() {
        return String::toUpperCase;
    }
}
----
As a Spring developer, you might be tempted to add the `@ComponentScan` annotation in order to define specific packages to scan for additional beans. Do note that `@ComponentScan` is entirely unnecessary since Quarkus performs link:cdi-reference#bean_discovery[bean discovery] only in `annotated` mode with no visibility boundaries. Moreover, note that the bean discovery in Quarkus happens at build time.
In the same vein, Quarkus does not support the Spring `@Import` annotation.

. Create a `src/main/java/org/acme/spring/di/NoOpSingleStringFunction.java` file that contains the `NoOpSingleStringFunction` bean.
The `NoOpSingleStringFunction` implements the `StringFunction` bean using the `@Component` stereotype annotation provided by Spring.
//TODO: this sounds a little ambiguous
This bean does not process the string, but returns the string as is.
+
[source,java]
----
package org.acme.spring.di;

import org.springframework.stereotype.Component;

@Component("noopFunction")
public class NoOpSingleStringFunction implements StringFunction {

    @Override
    public String apply(String s) {
        return s;
    }
}
----

//. Quarkus also provides support for injecting configuration values using Spring's `@Value` annotation.
. With Quarkus, you can also use the `@Value` annotations to inject inject values of configuration properties into beans.
.. Set the value of the `greeting.message` property to `hello` in the `src/main/resources/application.properties` file:
+
[source,properties]
----
# Your configuration properties
greeting.message = hello
----

.. Create the `src/main/java/org/acme/spring/di/MessageProducer.java` file that contains a `MessageProducer` bean.
Use the `@Value` annotation to set the value of the `greeting.message` property as the message String inside the `MessageProducer` bean:
+
[source,java]
----
package org.acme.spring.di;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class MessageProducer {

    @Value("${greeting.message}")
    String message;

    public String getPrefix() {
        return message;
    }
}
----

//The final bean we will create ties together all the previous beans.
. Create the `src/main/java/org/acme/spring/di/GreeterBean.java` file that contains the code shown in the example below.
Note, that the `GreeterBean` bean relies on both contructor-based and field-based injection.
In the example below, you do not need to use the `@Autowired` annotation on the field-based constructor, because the bean only contains a single field-based constructor.
Also note, that the `@Value` annotation on the `suffix` String has a default value assigned. The default value is used because you have not previously defined a `greeting.suffix` in the `application.properties` file.
+
[source,java]
----
package org.acme.spring.di;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class GreeterBean {

    private final MessageProducer messageProducer;

    @Autowired
    @Qualifier("noopFunction")
    StringFunction noopStringFunction;

    @Autowired
    @Qualifier("capitalizeFunction")
    StringFunction capitalizerStringFunction;

    @Value("${greeting.suffix:!}")
    String suffix;

    public GreeterBean(MessageProducer messageProducer) {
        this.messageProducer = messageProducer;
    }

    public String greet(String name) {
        final String initialValue = messageProducer.getPrefix() + " " + name + suffix;
        return noopStringFunction.andThen(capitalizerStringFunction).apply(initialValue);
    }
}
----

[id="updating-the-jax-rs-resource_{context}"]
=== Updating the JAX-RS resource

Open the `src/main/java/org/acme/spring/di/GreeterResource.java` file and update it with the following content:

[source,java]
----
package org.acme.spring.di;

import org.springframework.beans.factory.annotation.Autowired;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/greeting")
public class GreeterResource {

    @Autowired
    GreeterBean greeterBean;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return greeterBean.greet("world");
    }
}
----

[id='updating-the-application-test_{context}']
== Updating the application test

[role="_abstract"]
You must update the functional test to reflect the changes that you made to the endpoint.

.Procedure

. Edit the `src/test/java/org/acme/spring/di/GreetingResourceTest.java` file and change the content of the `testHelloEndpoint` method to the following:
+
[source, java]
----
import io.quarkus.test.junit.QuarkusTest;
import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured.given;
import static org.hamcrest.CoreMatchers.is;

@QuarkusTest
public class GreetingResourceTest {

    @Test
    public void testHelloEndpoint() {
        given()
            .when().get("/greeting")
            .then()
                .statusCode(200)
                .body(is("HELLO WORLD!"));
    }

}
----

[id="packaging-and-running-your-application_{context}"]
== Packaging and running your application:

//[role="_abstract"]
.Procedure

. To compile and run your application in development mode, execute the following command in the project directory:
+
[source,bash]
----
./mvnw compile quarkus:dev
----

. Navigate to `http://localhost:8080/greeting` using a web browser. You receive `HELLO WORLD!` as a response.

. To stop the application, press kbd:[CTRL+C].

== Running your the application in native mode

You can of course create a native image using instructions similar to link:building-native-image[this] guide.

//TODO: MOve this up front, make it a con_
== Important Technical Note

Please note that the Spring support in Quarkus does not start a Spring Application Context nor are any Spring infrastructure classes run.
Spring classes and annotations are only used for reading metadata and / or are used as user code method return types or parameter types.
What that means for end users, is that adding arbitrary Spring libraries will not have any effect. Moreover Spring infrastructure
classes (like `org.springframework.beans.factory.config.BeanPostProcessor` , `org.springframework.context.ApplicationContext` for example) will not be executed.
Regarding the dependency injection in particular, Quarkus uses a Dependency Injection mechanism (called ArC) based on the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0] specification. If you want to learn more about it we recommend you to read the link:cdi[Quarkus introduction to CDI] and the link:cdi-reference#arc-configuration-reference[CDI reference guide]
The various Spring Boot test features are not supported by Quarkus. For testing purposes, please, check the link:getting-started-testing[Quarkus testing guide].

//REF
[id="overview-of-annotation-equivalents-in-spring-di-and-cdi"]
== Overview of annotation equivalents in Spring DI and CDI

//[role="_abstract"]
The following table shows how Spring DI annotations can be converted to CDI and / or MicroProfile annotations.

|===
|Spring |CDI / MicroProfile |Comments

|`@Autowired`
|`@Inject`
|

|`@Qualifier`
|`@Named`
|

|`@Value`
|`@ConfigProperty`
|`@ConfigProperty` does not support an expression language the way `@Value` does, but makes the typical use cases much easier to handle

|`@Component`
|`@Singleton`
|By default Spring stereotype annotations are singleton beans

|`@Service`
|`@Singleton`
|By default Spring stereotype annotations are singleton beans

|`@Repository`
|`@Singleton`
|By default Spring stereotype annotations are singleton beans

|`@Configuration`
|`@ApplicationScoped`
|In CDI a producer bean is not limited to the application scope, it could just as well be `@Singleton` or `@Dependent`

|`@Bean`
|`@Produces`
|

|`@Scope`
|
|Does not have a one-to-one mapping to a CDI annotation. Depending on the value of `@Scope`, you can use `@Singleton`, `@ApplicationScoped`, `@SessionScoped`, `@RequestScoped`, or `@Dependent`
|===


//[role="_additional-resources"]
//.Additional resources

// next steps?  links
//might have to be ommitted from the product version
== More Spring guides

Quarkus has more Spring compatibility features. See the following guides for more details:

* link:spring-web[Quarkus - Extension for Spring Web]
* link:spring-data-jpa[Quarkus - Extension for Spring Data JPA]
* link:spring-data-rest[Quarkus - Extension for Spring Data REST]
* link:spring-security[Quarkus - Extension for Spring Security]
* link:spring-cloud-config-client[Quarkus - Reading properties from Spring Cloud Config Server]
* link:spring-boot-properties[Quarkus - Extension for Spring Boot properties]
* link:spring-cache[Quarkus - Extension for Spring Cache]
* link:spring-scheduled[Quarkus - Extension for Spring Scheduled]
