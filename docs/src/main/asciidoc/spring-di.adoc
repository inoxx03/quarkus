//TODO: What should we do with this?
////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
////
//TODO: need to use product attributes, but also keep compatibility with community ones

// comment out to show community version
:product-docs:
// TODO: consider moving this to the attributes file
:doctype: book

//Top-Level Assembly
[id="using-the-quarkus-extension-for-spring-di-api_{context}"]
= Using the Quarkus Extension for Spring DI API

ifdef::context[:parent-context: {context}]

:context: using-the-quarkus-extension-for-spring-di

include::./attributes.adoc[]

[role="_abstract"]
The `quarkus-spring-di` extension provides a compatibility layer for Spring Dependency Injection that you can use as an alternative to MicroProfile CDI annotations in your {ProductName} application.
This guide explains how your {ProductName} application can leverage Dependency Injection annotations provided by the Spring Framework.

ifndef::product-docs[]

This guide is maintained in the main {ProductName} repository and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc

== Solution

Follow the instructions in the next sections and create the application step by step.
Alternatively, you can clone and use the completed example.

Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].

The solution is located in the `spring-di-quickstart` {quickstarts-tree-url}/spring-di-quickstart[directory].
endif::[]

// Tech preview info for community purposes, different from product
ifndef::product-docs[]
include::./status-include.adoc[]
:extension-status: preview
endif::[]

//tech preview info for product docs
ifdef::product-docs[]
NOTE: The `quarkus-spring-di` extension is available as link:https://access.redhat.com/support/offerings/techpreview[Technology Preview] with {ProductLongName}.
endif::[]


//ifdef::product-docs[]
[IMPORTANT]
====
The Spring compatibility layer that {ProductName} provides does not start a Spring Application Context or execute any infrastructure classes that are provided by Spring (for example, `org.springframework.beans.factory.config.BeanPostProcessor`) when you start your application.
{ProductName} can only read metadata from Spring classes and annotations and parse user code method return types and parameter types that are specific to Spring.
However, when you add arbitrary libraries that are part of Spring Framework to your {ProductName} application, such libraries will not function properly, because {ProductName} is not able to use them.
====
//endif::[]

.Prerequisites

// comment out the following prerequisite in the alternative 1 layout of the document.
* Have a {ProductName} Maven project.
* Have OpenJDK 8 installed.
* Have Maven {maven-version} installed.

// Alternative 1: generate project form scratch
////
[id="creating-the-spring-di-example-maven-project_{context}"]
== Creating the Spring DI example Maven project

[role="_abstract"]
You can create new a new Maven project for the Spring DI example application on the command line.

.Procedure

. Execute the following commands to:

* generate the directory structure of the project.
* create the main class file of the example application.
* create the endpoint that exposes the service that your application provides.
* add the `quarkus-spring-di` extension to the `pom.xml` file of your project.
* navigate to the top-level directory of your project .
+
[source,bash,subs=attributes+]
----
mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=spring-di-quickstart \
    -DclassName="org.acme.spring.di.GreeterResource" \
    -Dpath="/greeting" \
    -Dextensions="resteasy,spring-di"
cd spring-di-quickstart
----
////

//Alternative 2: you have a project and need to add the required extension.
[id="setting-up-your-spring-di-maven-project_{context}"]
== Setting up your Spring DI example Maven project

[role="_abstract"]
Add the required {ProductName} extension as a dependency of your Maven project.

.Procedure

. Navigate to the the top-level directory of your {ProductName} Maven project:
+
[source,bash,options="nowrap",subs="+quotes,attributes+"]
----
cd <name-of-your-project-directory>
----

. Execute the following command to add the `quarkus-spring-di` extension to the `pom.xml` file of your project:
+
[source,bash]
----
./mvnw quarkus:add-extension -Dextensions="spring-di"
----
ifndef::product-docs[]
+
This adds the following entry to your `pom.xml` file:

[source,xml,options="nowrap",subs="+quotes,attributes+"s]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-spring-di</artifactId>
</dependency>
----
endif::[]


[id="additng-beans-to-your-applications-using-spring-annotations"]
== Adding beans to your application using Spring annotations

[role="_abstract"]
You can add the required beans to your {ProductName} application using annotations provided by Spring.

.Procedure
. Navigate to the the top-level directory of your {ProductName} Maven project:
+
[source,bash,options="nowrap",subs="+quotes,attributes+"]
----
cd <name-of-your-project-directory>
----

. Create the `src/main/java/org/acme/spring/di/StringFunction.java` file that contains a `StringFunction` interface.
+
.src/main/java/org/acme/spring/di/StringFunction.java
[source,java]
----
package org.acme.spring.di;

import java.util.function.Function;

public interface StringFunction extends Function<String, String> {

}
----
+
The `GreeterBean` and `NoOpSingleStringFunction` beans that are part of the Spring DI example application also implement the `StringFunction` interface.
//Other beans in this example implement this interface, and the interface is injected into another bean later on.

. Create the `src/main/java/org/acme/spring/di/AppConfiguration.java` file.
Inside the file that you created, create an `AppConfiguration` class and annotate it with the `@Configuration` annotation provided by Spring Java Config.
Inside the `AppConfiguration` class, create a `StringFunction` bean that changes a string that you pass to it to uppercase:
+
[source,java,options="nowrap",subs="+quotes,attributes+"]
----
package org.acme.spring.di;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfiguration {

    @Bean(name = "capitalizeFunction")
    public StringFunction capitalizer() {
        return String::toUpperCase;
    }
}
----
As a Spring developer, you might be tempted to add the `@ComponentScan` annotation in order to define specific packages to scan for additional beans. Do note that `@ComponentScan` is entirely unnecessary since Quarkus performs link:cdi-reference#bean_discovery[bean discovery] only in `annotated` mode with no visibility boundaries. Moreover, note that the bean discovery in Quarkus happens at build time.
In the same vein, Quarkus does not support the Spring `@Import` annotation.

. Create a `NoOpSingleStringFunction` bean inside the the `src/main/java/org/acme/spring/di/NoOpSingleStringFunction.java` file.
The `NoOpSingleStringFunction` implements the `StringFunction` interface using the `@Component` stereotype annotation provided by Spring.
This bean returns the string without processing it:
+
.src/main/java/org/acme/spring/di/NoOpSingleStringFunction.java
[source,java,options="nowrap",subs="+quotes,attributes+"]
----
package org.acme.spring.di;

import org.springframework.stereotype.Component;

@Component("noopFunction")
public class NoOpSingleStringFunction implements StringFunction {

    @Override
    public String apply(String s) {
        return s;
    }
}
----
+
//. Quarkus also provides support for injecting configuration values using Spring's `@Value` annotation.
. In {ProductName} applications, you can also use the `@Value` annotations to inject values of configuration properties into beans:
.. Set the value of the `greeting.message` property to `hello` in the `src/main/resources/application.properties` file:
+
[source,properties,options="nowrap",subs="+quotes,attributes+"]
----
# Your configuration properties
greeting.message = hello
----
+
.. Create the `src/main/java/org/acme/spring/di/MessageProducer.java` file.
Inside the file crate a `MessageProducer` bean.
Use the `@Value` annotation to set the value of the `greeting.message` property as the message String inside the `MessageProducer` bean:
+
[source,java]
----
package org.acme.spring.di;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class MessageProducer {

    @Value("${greeting.message}")
    String message;

    public String getPrefix() {
        return message;
    }
}
----
+
//The final bean we will create ties together all the previous beans.
. Create the `src/main/java/org/acme/spring/di/GreeterBean.java` file that contains the code shown in the example below.
The `GreeterBean` bean relies on both constructor-based and field-based injection.
You do not need to use the `@Autowired` annotation on the field-based constructor, because the bean only contains a single field-based constructor.
The `@Value` annotation on the `suffix` String contains a default value, which is used when you do not set a value for the `greeting.suffix` property in the `application.properties` file.
+
.src/main/java/org/acme/spring/di/GreeterBean.java
[source,java,options="nowrap",subs="+quotes,attributes+"]
----
package org.acme.spring.di;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class GreeterBean {

    private final MessageProducer messageProducer;

    @Autowired
    @Qualifier("noopFunction")
    StringFunction noopStringFunction;

    @Autowired
    @Qualifier("capitalizeFunction")
    StringFunction capitalizerStringFunction;

    @Value("${greeting.suffix:!}")
    String suffix;

    public GreeterBean(MessageProducer messageProducer) {
        this.messageProducer = messageProducer;
    }

    public String greet(String name) {
        final String initialValue = messageProducer.getPrefix() + " " + name + suffix;
        return noopStringFunction.andThen(capitalizerStringFunction).apply(initialValue);
    }
}
----

[id="updating-the-jax-rs-resource_{context}"]
== Updating the JAX-RS resource
// Updating GreeterResource.java

[role="_abstract"]
When you create the class files of your example applications, you must update the `GreeterResource.java` file to reflect the changes that you made to the `/greeting` endpoint.

.Procedure

. Add the following content to the `src/main/java/org/acme/spring/di/GreeterResource.java` file:
+
.src/main/java/org/acme/spring/di/GreeterResource.java
[source,java,options="nowrap",subs="+quotes,attributes+"]
----
package org.acme.spring.di;

import org.springframework.beans.factory.annotation.Autowired;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/greeting")
public class GreeterResource {

    @Autowired
    GreeterBean greeterBean;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return greeterBean.greet("world");
    }
}
----

[id='updating-the-integration-test-of-your-application_{context}']
== Updating the integration test of your application

[role="_abstract"]
You must update the class file that contains the integration test for your application to reflect the changes that you made to the `/greeting` endpoint.

.Procedure

. Edit the `src/test/java/org/acme/spring/di/GreetingResourceTest.java` file and change the content of the `testHelloEndpoint` method as shown in the example below:
+
.src/test/java/org/acme/spring/di/GreetingResourceTest.java
[source,java,options="nowrap",subs="+quotes,attributes+"]
----
import io.quarkus.test.junit.QuarkusTest;
import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured.given;
import static org.hamcrest.CoreMatchers.is;

@QuarkusTest
public class GreetingResourceTest {

    @Test
    public void testHelloEndpoint() {
        given()
            .when().get("/greeting")
            .then()
                .statusCode(200)
                .body(is("HELLO WORLD!"));
    }

}
----

[id="packaging-and-starting-your-spring-di-example-application_{context}"]
== Packaging and starting your Spring DI example application

[role="_abstract"]
Package and start your Spring DI example application using Maven.

.Procedure

. Navigate to the the top-level directory of your {ProductName} Maven project:
+
[source,bash,options="nowrap",subs="+quotes,attributes+"]
----
cd <name-of-your-project-directory>
----

. Execute the following command to compile and start your application in development mode:
+
[source,bash,options="nowrap",subs="+quotes,attributes+"]
----
./mvnw compile quarkus:dev
----

. Navigate to `http://localhost:8080/greeting` using a web browser.
You receive `HELLO WORLD!` as the response.

. Press _CTRL + C_ to stop the application.


ifndef::product-docs[]
== Compile and start the application as a native executable

You can create a native image by following the guide about link:building-native-image[Building a Native Executable].
endif::[]

////
//ifndef::product-docs[]
//TODO: This note is replaced by a rewritten version that is based on style mandated by the IBM style guide.
//Only the -product-appropriate wording of the note should be used in both the community and product versions of this document.
//I am retaining the original wording for purposes of verification and factual corrections.

== Important technical note

Spring support in {ProductName} does not start a Spring Application Context nor are any Spring infrastructure classes run.
Spring classes and annotations are only used for reading metadata and / or are used as user code method return types or parameter types.
What that means for end users, is that adding arbitrary Spring libraries will not have any effect. Moreover Spring infrastructure
classes (like `org.springframework.beans.factory.config.BeanPostProcessor` , `org.springframework.context.ApplicationContext` for example) will not be executed.

Regarding the dependency injection in particular, Quarkus uses a Dependency Injection mechanism (called ArC) based on the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0] specification. If you want to learn more about it we recommend you to read the link:cdi[Quarkus introduction to CDI] and the link:cdi-reference#arc-configuration-reference[CDI reference guide]
The various Spring Boot test features are not supported by Quarkus. For testing purposes, please, check the link:getting-started-testing[Quarkus testing guide].
//endif::[]
////

//BEGIN: REFERENCE module
[id="overview-of-annotation-equivalents-in-spring-di-and-cdi"]
== Overview of annotation equivalents in Spring DI and CDI

[role="_abstract"]
The following table lists Spring DI annotations and their equivalent CDI annotations or MicroProfile annotations, respectively.

[options="header"]
|===
|Spring Annotation |CDI / MicroProfile Annotation |Note

|`@Autowired`
|`@Inject`
|

|`@Qualifier`
|`@Named`
|

|`@Value`
|`@ConfigProperty`
|`@ConfigProperty` does not support an expression language the way `@Value` does, but makes the typical use cases much easier to handle

|`@Component`
|`@Singleton`
|By default Spring stereotype annotations are singleton beans

|`@Service`
|`@Singleton`
|By default Spring stereotype annotations are singleton beans

|`@Repository`
|`@Singleton`
|By default Spring stereotype annotations are singleton beans

|`@Configuration`
|`@ApplicationScoped`
|In CDI a producer bean is not limited to the application scope, it could just as well be `@Singleton` or `@Dependent`

|`@Bean`
|`@Produces`
|

|`@Scope`
|
|Does not have a one-to-one mapping to a CDI annotation. Depending on the value of `@Scope`, you can use `@Singleton`, `@ApplicationScoped`, `@SessionScoped`, `@RequestScoped`, or `@Dependent`
|===
//END: REFERENCE module

ifdef::product-docs[]
[role="_additional-resources"]
.Additional resources
* link:building-native-image[Compiling and starting your {ProductName} application as a native executable.]
endif::[]

ifndef::product-docs[]
== More Spring guides

{ProductName} provides more Spring compatibility features.
See the following guides for details:

* link:spring-web[{ProductName} - Extension for Spring Web]
* link:spring-data-jpa[{ProductName} - Extension for Spring Data JPA]
* link:spring-data-rest[{ProductName} - Extension for Spring Data REST]
* link:spring-security[{ProductName} - Extension for Spring Security]
* link:spring-cloud-config-client[{ProductName} - Reading properties from Spring Cloud Config Server]
* link:spring-boot-properties[{ProductName} - Extension for Spring Boot properties]
* link:spring-cache[{ProductName} - Extension for Spring Cache]
* link:spring-scheduled[{ProductName} - Extension for Spring Scheduled]
endif::[]

ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]
